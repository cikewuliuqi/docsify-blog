

### IOC

#### 1 什么是IOC：

​		全称inverse of control 控制反转，是将创建对象的控制权交给spring框架，是一种设计思想，用于简化Java开发



#### 2 什么是IOC容器：

​		spring实现IOC的载体，它实际就是一个map（key,value）里面存放各种对象



#### 3 IOC容器的作用：

​		管理对象以及对象之间的依赖关系，简化了开发复杂度，达到解耦效果。



#### 5 依赖倒置原则、控制反转、控制反转容器、依赖注入四者之间的关系：

​		依赖倒置原则的代码设计思路就是IOC

​		实现IOC的载体就是IOC容器

​		spring IOC的实现方法是DI



#### 6 何为依赖倒置原则：

​		把原本的高层建筑依赖底层建筑倒置过来，编程底层建筑依赖高层建筑。高层建筑决定需要什么，底层建筑实现这样的需求，而高层建筑不必知晓底层建筑是如何实现的。



#### 7 何为依赖注入：

​		把底层类作为参数传入上层类，实现上层类对下层类的控制。

​		如果上层类依赖下层类，即每一个类的构造函数都直接调用了底层类的构造函数，这样会导致牵一发而动全身，这样的设计是不可维护的。

==补充==：

​		之前采用的方法是在上层类中的构造器里面用new关键字来创建需要的下层类，这样虽然简单但是会导致上层类依赖于底层类的构造函数。

​		现在采用的方法是把底层类作为参数传入上层类，这种注入的方式，使得整个流程只能从底层类一个个新建出对象，改动量会很少。



#### 8 结合实际项目说说IOC容器的作用：

​		在项目开发时，每次我们写一个类，就需要写相应的配置文件，告诉spring框架自己放入容器中管理以及自己的依赖关系。当我们需要用到该类时，如果没有IOC容器，我们采用依赖注入的方式，在初始化过程中会写大量的new。如果有的话，IOC容器就会自动对我们的代码进行初始化，你只需要维护一个配置文件或者配置类即可。这样我们需要用到哪个类就直接注入，不需要考虑各种各种类的依赖关系，起到简化Java开发。



#### 9 何为解耦：

​		一个对象的更改也需要另一个对象的更改，这就是耦合。如果耦合度过高，则代码的维护成本会变大，所以我们需要解耦。

(记住脑图)

​		spring框架利用第三方的IOC容器和每一个对象关联，使得原来对象之间的互相关联的状态变为彼此之间不在直接关联的状态，这就是解耦。实际项目中的体现就是把对象之间的依赖关系转换为配置文件，每次做修改，只需要修改配置文件即可。



#### 10 配置文件的方式玩转IOC和DI：

1.  实例化bean对象：写接口和实现类，配置文件中声明需要管理的类，配置类的ID、类的全路径、作用域、初始化方法、销毁方法。
2. 想玩DI，则先写需要注入的接口和实现类，然后在被注入的类中提供成员变量以及set方法，最后配置文件中写明关系即可，properties中写name和ref，将类注入到name属性上去。

==补充==：

xml中写文档声明和约束

jar包就是把别人已经写好的类进行打包，我们放入到自己的项目中，可以直接使用jar包中类的属性和方法

Maven仓库的几个概念

作用：用于管理jar包，利用插件进行打包和测试等等。

特点：传递依赖和最近依赖策略

jar的查找坐标：groupID、artifactid、version组成 



#### 11 Bean标签属性有哪些？

ID：唯一标识

class：类全路径

scope:作用域 分为四个 singleton prototype session request 

<init-method> 对象创建后初始化方法

<destoy-method>  对象销毁后调用的方法

注意：单实例和多实例的生命周期不一样：单实例对象比较少，所以生命周期和容器一样，配置文件一被加载，实例对象立马被加载；多实例对象比较多，所以销毁后由垃圾收集器负责，且遵行懒加载的思想，在获取对象的时候才会创建实例对象。



#### 12 实例化Bean对象的三种方式

实例化bean对象的意思就是：将写好的类交给IOC容器管理

1. 普通构造函数创建：接口和实现类 + bean节点  

2. 静态工厂创建：利用一个类的静态方法new实例对象 主要是bean标签中多加入 factory-method

3. 实例工厂创建：利用一个类的普通方法new实例对象  主要是两个bean标签，一个用于获取工厂实例，一个用户通过工厂实例指定方法获取实例对象。

总和三种方式，用的最多的就是第一种，简单方便。

#### 13 依赖注入的三种注入方式

注入本质上都是创建对象和给对象属性赋值，关键在于实现解耦功能。

例如A调用B的方法时，那么A依赖于B的接口也依赖于B的实现类，这样耦合度就很高。利用注入方式就可以使得A只依赖B的接口

注入方式一：构造器注入 

注入方式二：setter方法注入 

注入方式三：接口注入 

总结来说：都是先给类的属性赋值完成后传到上层类使用。目前大部分框架对PO的封装都是无参构造函数，然后调用setter方法给属性赋值

#### 14 注入常用类型

普通类型 引用类型（默认按名称装配）

#### 15 注解方式的方式玩转IOC和DI

用配置类代替配置文件，主要是通过注解来取代配置文件，此时需要开启注解扫描。

@Configuration 申明为配置类或者 @Contriller @Service @Repository

@ComponmentScan(value=“cn.tx.demo”)  自动扫描的位置说明



这两个注解起到实例化bean对象的作用

然后引入依赖注入类型的注解：

@Value(value=“40000”) 普通类型

@Autowired 直接注入引用类型

例外几种常见注解：

@Qualifier 配上@Autowired强制按名称装配

@Resource 按名称装配，java自带的

注入的时候如果要加些额外属性：

@Scope  @PostConstruct @preDestroy

#### 16 其他注解

@import 用于导入其他配置类

@Bean 支持第三方开源库

### AOP

#### 1 什么是AOP？

AOP是一种思想，是在运行时，动态地将代码切入到指定方法、指定位置的编程思想。她是oop的补充。oop解决竖向问题，aop解决横向问题。

#### 2 AOP的作用？

1. 减少重复代码
2. 关注业务代码

==补充==：面向对象的封装特点使得各个类与类之间各司其职且无法联系，但是在实际业务开发中每个类都有重复代码，为了降重，如果我们把公共的代码抽取出来放入独立的类中，分别关联于需要的类会增加耦合度，所以提出了面向切面的编程思想。在我们需要的时候随意加入代码，从而改变原有的行为。这种方式是动态的，没有直接写死。故各个类依旧没有很高的耦合度。



#### 3 AOP的应用场景？

事务处理 异常处理 日志记录等这些



#### 4 AOP的实现方式？

AOP是通过动态代理实现的，如果代理对象实现了某个接口，那么SpringAop会使用JDKproxy去创建动态代理。

如果代理对象没有实现接口，则SpringAop会使用Cglib去创建代理对象。

补充：代理模式分为静态代理和动态代理，区别在于动态代理是在运行时通过反射的方式产生代理对象

补充：最好能手写代码实现两种模式，有时间自己写一下



#### 5 AOP相关概念

最重要的两个概念：

切入点：程序增强的入口

通知：增强的代码

```java
@Aspect
@Component
public class LogAspect {
    @Pointcut("execution(void com.saligia.spring.aop.aspectj.Persion.say())")    
    public void pointCut(){}
    @Before("pointCut()") 
    public void log(){        
        System.out.println("Before say : ");    
    } 
}
```

自定义的切面类 = 切入点 + 通知

@Pointcut关联为我们要处理的切入点是say()方法 @Before告诉在执行say()方法之前需要执行的方法

#### 6 哪几种通知类型？

通知是指我们事件的具体逻辑内容(比如上面的`log()`), 以及触发的时机既在切点的是么时候触发,Spring 有 5种类型的触发时机可以使用 :

- 前置通知(@Before) : 在目标方法被调用之前调用通知功能
- 后置通知(@After) : 在方法返回或者抛出异常后调用通知。
- 返回通知(@AfterReturning) : 在目标方法被调用之后调用通知。
- 异常通知(@AfterThrowing) : 在目标方法抛出异常之后调用通知。
- 环绕通知(@Around) :通知包裹了被通知的方法,通知的方法调用之前和调用之后执行自定义的行为。

补充：最好能手写一个自动增强的功能

### Spring事务传播行为

#### 1 什么是事务传播？

简单来说就是一个事务方法被另外一个事务方法调用时，该事务是在另外一个事务中运行，还是自己单独新建使用自己的事务，这就取决于自身的事务传播行为。

####  2 何为Spring事务传播行为？

#### 3 Spring事务管理的方式有哪些？

Spring支持编程式事务管理和声明式事务管理，官方推荐使用后者，因为使用AOP实现，所以代码侵入性小。也就是我们常用的@transaction注解

#### 4 事务接口联系是怎么样的？

![img](https://img-blog.csdnimg.cn/20190613234506839.png)

事务属性包含五个方面：隔离级别、传播行为、事务超时、回滚规则和只读

基本的使用：

先在类中注入事务管理器，然后在需要实现事务的方法上添加@Transactional注解，最后通过调用TransactionManager的commit()和rollback()实现事务提交和回滚。

事务管理的方式：

Spring不是直接对事务进行管理，而是通过PlatformTransactionManager接口将职责委托给不同的ORM框架的事务来实现。

#### 5 Spring事务传播行为有哪些？

1. PROPAGATION_REQUIRED
2. PROPAGATION_SUPPORTS
3. PROPAGATION_MANDATORY
4. PROPAGATION_REQUIRED_NEW
5. PROPAGATION_NOT_SUPPORTED
6. PROPAGATION_NEVER
7. PROPAGATION_NESTED

注意：PROPAGATION_NESTED类似于PROPAGATION_REQUIRED_NEW，但前者是两个独立的事务，而它是嵌套事务。

#### 6 事务传播行为的区别？

1. NESTED 和 REQUIRED 修饰的内部方法都属于外围方法事务，如果外围方法抛出异常，这两种方法的事务都会被回滚。

   但是 REQUIRED 是==加入====外围方法事务==，所以和外围事务同属于一个事务，一旦 REQUIRED 事务抛出异常被回滚，外围方法事务也将被回滚。

   而 NESTED 是==外围方法的子事务==，有单独的保存点，所以 NESTED 方法抛出异常被回滚，不会影响到外围方法的事务。

2. NESTED 和 REQUIRES_NEW 都可以做到内部方法事务回滚而不影响外围方法事务。

   但是因为 NESTED 是嵌套事务，所以外围方法回滚之后，作为外围方法事务的子事务也会被回滚。

   而 REQUIRES_NEW 是通过开启新的事务实现的，内部事务和外围事务是两个事务，外围事务回滚不会影响内部事务。

总结：为什么有这么多的传播行为，也就是为了考虑所有的情况，满足所有的需求场景而已。





### Spring

#### 1 何为Spring框架？

一款轻量级的开发框架，用来提高开发效率

#### 2 Spring的优点有哪些？

1. 最小侵入式开发，对现有类结构没有影响的情况下就能增强javabean的功能
2. 通过依赖注入和面向接口实现松耦合
3. 基于切面进行声明式编程
4. 通过切面和模板减少样板式代码

#### 3 Spring为我们做了哪些具体的事？

创建对象、处理对象之间的依赖关系、对象创建的时间或者对象的数量。我们都是在spring提供的IOC容器中配置对象的信息就可以了。

#### 4 spring模块有哪些？

重要的模块有：

Spring Core    主要提供IOC注入功能

Spring Web    Spring对WEB模块的支持

Spring ORM   支持ORM工具

Spring AOP   提供面向方面的编程实现

#### 5 Spring中的单例bean是否线程安全？

结论：不是线程安全的

对于单例bean,所有线程都共享一个单例Bean，因此是存在资源的竞争。

解决措施：(这里每次只说一个，诱导面试官自己追问)

1. 简单的方法就是把bean的作用域由singleton变为prototype

2. 使用ThreadLocal把变量变为线程私有

3. 假如我们需要bean的实例对象或者类变量在多个线程中共享，那么只能使用Synchronized、lock、CAS等实现线程同步

给我们的启示是：

我们在设计bean的时候，尽量不要声明有状态的实例变量或者类变量，使之成为一个无状态的对象，这样就完全不受多线程的影响，自然就是线程安全的。

#### 6 Spring中的bean生命周期？

对于普通的Java对象，当我们new的时候创建对象，如果对象没有任何引用的时候就会GC掉。

Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于多例模式Bean，则只负责创建对象并给使用者使用



![img](https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9TxB4lWZ4f6psb2gpZMGX4dmyw0sBbfhytV4u9qz29ZPqWzznjGSZQNxoCxWTib6LlZHIbQyLK4evmA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

对于如上这些方法，我们可以分成如下几类

1. Bean自身的方法：比如构造函数、getter/setter以及init-method和destory-method所指定的方法等
2. Bean级生命周期方法：可以理解为Bean类直接实现接口的方法
3. 容器级的方法(BeanPostProcessor一系列接口)：主要是后处理器方法，在Spring容器创建任何Bean的时候，这些后处理器都会发生作用。
4. 工厂后处理器方法（BeanFactoryProcessor一系列接口）：这些都是Spring框架中已经实现好的BeanFactoryPostProcessor，用来实现某些特定的功能。

Bean自身的方法和Bean级生命周期方法都只对当前Bean起作用，但是容器级生命周期方法和工厂后处理器方法是对所有的bean都起作用

#### 7  SpringMVC 工作原理了解吗

**流程说明（重要）：**

1. 客户端（浏览器）发送请求，直接请求到 `DispatcherServlet`。
2. `DispatcherServlet` 根据请求信息调用 `HandlerMapping`，解析请求对应的 `Handler`。
3. 解析到对应的 `Handler`（也就是我们平常说的 `Controller` 控制器）后，开始由 `HandlerAdapter` 适配器处理。
4. `HandlerAdapter` 会根据 `Handler`来调用真正的处理器开处理请求，并处理相应的业务逻辑。
5. 处理器处理完业务后，会返回一个 `ModelAndView` 对象，`Model` 是返回的数据对象，`View` 是个逻辑上的 `View`。
6. `ViewResolver` 会根据逻辑 `View` 查找实际的 `View`。
7. `DispaterServlet` 把返回的 `Model` 传给 `View`（视图渲染）。

### SpringBoot

#### 1 SpringBoot重要的两种设计策略是什么？

开箱即用和约定大于配置

开箱即用：通过Maven项目中的pom文件中添加相应依赖包，然后通过相应的注解来替代繁琐的XML配置以及管理对象的生命周期

约定大于配置：由SpringBoot本身来配置目标结构，开发者在结构中添加信息的软件设计范式。简单一句话就是我规定你在哪里写，你就哪里写。虽然降低灵活性但是增加了自动化。



