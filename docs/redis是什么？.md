### redis是什么？

redis是C语言开发开源的高性能键值对的内存数据库，用作数据库、消息中间件、缓存等，是nosql数据库

### 你的项目中用到了Redis，为什么用redis ?

因为传统的关系型数据库（如mysql）已经不能满足所有的常见，例如app首页访问流量高峰或者秒杀库存扣减都会轻易击垮数据库，所以引入了缓存中间件，目前市面上常用的缓存中间件有Redis和memcached，不过中和考虑他们的优缺点，最后选择了Redis。

### redis的特点 ？

1. 高性能高并发，由于Redis是基于内存的数据库，所以读写速度很快且支持并发10W 的QPS
2. 单线程单进程是线程安全
3. 支持IO多路复用模型，是非阻塞的IO
4. 数据结构简单且操作数据简单
5. 支持数据持久化，即把内存中的数据持久化到磁盘

### 说说常见的数据类型及其使用场景？

1. string类型：他是Redis最基础的类型，一个key对应一个value,且是二进制安全的，可以包含任何数据，如图片、视频、序列化对象等等
2. hash 键值对集合，适合存储和修改对象，用于存储、读取、修改用户属性，常用的命令有：hset hget hgetall
3. list 双向链表，增删快，提供操作某一元素的API，用于最新消息排行和消息队列，常用的命令为lpush lpop rpush rloop等等
4. set 无序不重复的集合，增删查的复杂度都是O（1），提供了求交集、并集、差集的操作,提供判断某个成员是否在一个set集合中。用来实现共同好友、统计网站的所有ip。常用的命令为sadd spop smember sunion
5. zset 讲set中的元素增加一个权重参数score。元素按照score有序排列，内部使用hashmap和skiplist来保证数据的存储和有序，用来实现排行版或者带权重的消息队列，常用命令有：zadd zrange zcard

### 详细说说布隆过滤器

概念：布隆过滤器是一个很长的二进制向量和一系列随机映射函数。可以用于检索一个元素是否在一个集合中

优缺点：优点是空间效率和查询时间都远远超与一般算法，缺点是有一定的误识别率和删除困难

原理：当一个元素被加入集合时，通过K个散列函数讲这个元素映射成一个位数组中的K个点，把它们置为1.检索时，我们只需要看这些点是不是都是1就知道集合中有没有它。（使用了K个哈希函数，降低冲突的概率）。

应用场景：防止缓存穿透、爬虫过滤已经爬取的url、垃圾邮件过滤等等

实现：使用布隆过滤器时，需要考虑预估数据量和期望的误判率。实现布隆过滤器时，需要考虑hash函数的选择和bit数组的大小。

实验结论：错误率越大，所需空间和时间越小，反之越大。

### 其他高级数据结构和高级功能

Bitmap：位图是支持按 bit 位来存储信息，可以用来实现 **布隆过滤器（BloomFilter）**；

HyperLogLog：供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV；

Geospatial：可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。有没有想过用Redis来实现附近的人？或者计算最优地图路径？

这三个其实也可以算作一种数据结构，不知道还有多少朋友记得，我在梦开始的地方，Redis基础中提到过，你如果只知道五种基础类型那只能拿60分，如果你能讲出高级用法，那就觉得你**有点东西**。

pub/sub：功能是订阅发布功能，可以用作简单的消息队列。

Pipeline：可以批量执行一组指令，一次性返回全部结果，可以减少频繁的请求应答。

Lua:redis支持提交lua脚本来执行一系列的功能。

事务：Redis 提供的不是严格的事务，只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去。

### 你在实际项目中使用缓存有遇到什么问题？

数据和数据库数据不一致问题：这个问题在分布式环境下非常容易出现，这时候如果项目对缓存的要求是强一致性，那么我们就不能使用缓存，否则我们就尽可能采取一些合适的缓存更新策略，例如更新数据库后及时更新缓存、缓存失败后增加重试机制

### 解释下缓存雪崩、缓存穿透、缓存击穿以及出现这些问题该怎么解决？

缓存雪崩是什么：



目前电商首页以及热点数据都会去做缓存，一般缓存都是定时任务去刷新，或者查不到之后去更新缓存，而定时任务刷新就有一个问题。举个栗子：如果首页所有Key的失效时间都是12小时，中午12点刷新的，我零点有个大促活动大量用户涌入，假设每秒6000个请求，本来缓存可以抗住每秒5000个请求，但是缓存中所有Key都失效了。此时6000个/秒的请求全部落在了数据库上，数据库必然扛不住，真实情况可能DBA都没反应过来直接挂了，此时，如果没什么特别的方案来处理，DBA很着急，重启数据库，但是数据库立马又被新流量给打死了。这就是我理解的缓存雪崩。总的一句话就是同一时间大面积key失效，瞬间Redis跟没有一样.



缓存雪崩的解决方案：



- 处理缓存雪崩简单，在批量往Redis存数据的时候，把每个Key的失效时间都加个随机值就好了，这样可以保证数据不会再同一时间大面积失效。

```java
setRedis（key, value, time+Math.random()*10000）;
```

- 如果Redis是集群部署，将热点数据均匀分布在不同的Redis库中也能避免全部失效。
- 或者设置热点数据永不过期，有更新操作就更新缓存就好了，电商首页的数据也可以用这个操作



缓存穿透是指缓存和数据库中都没有的数据，而用户（黑客）不断发起请求，举个栗子：我们数据库的id都是从1自增的，如果发起id=-1的数据或者id特别大不存在的数据，这样的不断攻击导致数据库压力很大，严重会击垮数据库。

解决方案：

- 缓存穿透我会在接口层增加校验，比如用户鉴权，参数做校验，不合法的校验直接return，比如id做基础校验，id<=0直接拦截。

- 我记得Redis里还有一个高级用法**布隆过滤器（Bloom Filter）**这个也能很好的预防缓存穿透的发生，他的原理也很简单，就是利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查DB刷新KV再return。



至于缓存击穿，这个跟缓存雪崩有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了DB，而缓存击穿是指一个Key非常热点，在不停地扛着大量的请求，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发直接落到了数据库上，就在这个Key的点上击穿了缓存。



解决方案：

- 缓存击穿的话，设置热点数据永不过期，或者加上互斥锁就搞定了。

```java
public static String getData(String key) throws InterruptedException {
        //从Redis查询数据
        String result = getDataByKV(key);
        //参数校验
        if (StringUtils.isBlank(result)) {
            try {
                //获得锁
                if (reenLock.tryLock()) {
                    //去数据库查询
                    result = getDataByDB(key);
                    //校验
                    if (StringUtils.isNotBlank(result)) {
                        //插进缓存
                        setDataToKV(key, result);
                    }
                } else {
                    //睡一会再拿
                    Thread.sleep(100L);
                    result = getData(key);
                }
            } finally {
                //释放锁
                reenLock.unlock();
            }
        }
        return result;
    }
```



### Redis有多快？

官方提供的数据可以达到100000+的QPS（每秒内的查询次数）

### Redis为什么这么快？

第一：Redis完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度是O(1)。

第二：数据结构简单，对数据操作也简单。

第三：采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程导致的CPU切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗。

第四：使用多路复用IO模型，非阻塞IO

### Redis这么快为什么还是单线程？

您是想问Redis这么快，为什么还是单线程的吧。Redis确实是单进程单线程的模型，因为Redis完全是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章的采用单线程的方案了（毕竟采用多线程会有很多麻烦）。

### Redis与memcached的区别？

- 1、存储方式上：memcache会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。redis有部分数据存在硬盘上，这样能保证数据的持久性。
- 2、数据支持类型上：memcache对数据类型的支持简单，只支持简单的key-value，，而redis支持五种数据类型。
- 3、使用底层模型不同：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
- 4、value的大小：redis可以达到1GB，而memcache只有1MB

### key的失效机制和淘汰策略有哪些？

**Redis**的过期策略，是有**定期删除+惰性删除**两种

定期指的是：默认100ms就随机抽一些设置了过期时间的key，去检查是否过期，过期了就删了。

**惰性删除**，查询的时候顺便检查key是否过期，过期就删了

最后就是上述两种都没顾及到的key就用 **内存淘汰机制**！

![preview](https://pic2.zhimg.com/v2-60c26f9cc1b6e25602b54ff0ace09066_r.jpg)

Redis4.0加入了LFU(least frequency use)淘汰策略，包括volatile-lfu和allkeys-lfu，通过统计访问频率，将访问频率最少，即最不经常使用的KV淘汰。



### 说说Redis的持久化机制？

redis为了保证效率，数据缓存在了内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。

Redis的持久化策略有两种：1、RDB：快照形式是直接把内存中的数据保存到一个dump的文件中，定时保存。2、AOF：把所有的对Redis的服务器进行修改的命令都存到一个文件里。

Redis默认是快照RDB的持久化方式。当Redis重启的时候，它会优先使用AOF文件来还原数据集，因为AOF文件保存的数据集通常比RDB文件所保存的数据集更完整。

### RDB和AOF的工作原理？

默认Redis是会以快照"RDB"的形式将数据持久化到磁盘的一个二进制文件dump.rdb。工作原理简单说一下：当Redis需要做持久化时，Redis会fork一个子进程，子进程将数据写到磁盘上一个临时RDB文件中。当子进程完成写临时文件后，将原来的RDB替换掉，这样的好处是可以copy-on-write。

AOF可以做到全程持久化，只需要在配置中开启 appendonly yes。这样redis每执行一个修改数据的命令，都会把它添加到AOF文件中，当redis重启时，将会读取AOF文件进行重放，恢复到redis关闭前的最后时刻。

### 如何选择RDB和AOF？

RDB的优点是：这种文件非常适合用于备份：比如，你可以在最近的24小时内，每小时备份一次，并且在每个月的每一天也备份一个RDB文件。这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB非常适合灾难恢复。RDB的缺点是：如果你需要尽量避免在服务器故障时丢失数据，那么RDB不合适你。

使用AOF的优点是会让redis变得非常耐久。可以设置不同的fsync策略，aof的默认策略是每秒钟fsync一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。缺点是对于相同的数据集来说，AOF的文件体积通常要大于RDB文件的体积。根据所使用的fsync策略，AOF的速度可能会慢于RDB。

redis支持同时开启RDB和AOF，系统重启后，redis会优先使用AOF来恢复数据，这样丢失的数据会最少。

### redis主从复制的过程？

1、设置主节点的地址和端口

2、建立套接字连接，成功则关联一个文件事件处理器

3、从节点发送Ping信号，主节点返回Pong，表明两边能互相通信

4、数据同步，主节点将所有数据发送给从节点

### 详细说明下数据同步过程。

1. 完整重同步：用于处理初次复制的情况
2. 部分重同步：用于处理断线后重复制的情况

前者：通过主服务器创建并发送RDB文件以及向从服务器发送保存在缓冲区里面的写命令来进行同步

后者：讲断开连接期间执行的命令发送给从服务器，从服务器接受并执行这些写命令，就可以更新了



### 部分重同步的实现？

1. 复制偏移量
2. 复制积压缓冲区（它是一个先进先出的队列，用来存放写命令）
3. 携带服务器运行ID

### 主从复制存在的问题以及哨兵的功能？

存在问题：

1、一旦主节点宕机，从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。

2、主节点的写能力受到单机的限制。

3、主节点的存储能力受到单机的限制。

4、原生复制的弊端在早期的版本中也会比较突出，比如：redis复制中断后，从节点会发起psync。此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时，可能会造成毫秒或秒级的卡顿。

哨兵的功能：

Redis Sentinel（哨兵）主要功能包括主节点存活检测、主从运行情况检测、通知、自动故障转移、主从切换。

### 哨兵的工作原理？

定期监控：每个Sentinel节点都需要定期执行以下任务：每个Sentinel以每秒一次的频率，向它所知的主服务器、从服务器以及其他的Sentinel实例发送一个PING命令

检测主观下线状态：如果一个实例距离最后一次有效回复PING命令的时间超过down-after-milliseconds所指定的值，那么这个实例会被Sentinel标记为主观下线。

确认主观下线状态：如果一个主服务器被标记为主观下线，那么正在监视这个服务器的所有Sentinel节点，要以每秒一次的频率确认主服务器的确进入了主观下线状态。

检测客观下线状态：如果一个主服务器被标记为主观下线，并且有足够数量的Sentinel（至少要达到配置文件指定的数量）在指定的时间范围内同意这一判断，那么这个主服务器被标记为客观下线。

选择领头的sentinel：对服务器进行操作

故障转移：已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器

​					已下线主服务器属下的所有从服务器改为复制新的主服务器

​					当下线的旧主服务器重新上线时，他会成为新的主服务器的从服务器

### Redis分布式锁了解多少？

因此业界常用的解决方案通常是借助于一个第三方组件并利用它自身的排他性来达到多进程的互斥。如：

- 基于 DB 的唯一索引。
- 基于 ZK 的临时有序节点。
- 基于 Redis 的参数。

首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：

- 互斥性。
- 不会发生死锁。
- 加锁和解锁必须是同一个客户端，。
- 具有容错性。

**加锁操作的正确姿势为：**

1. 使用setnx命令保证互斥性
2. 需要设置锁的过期时间，避免死锁
3. setnx和设置过期时间需要保持原子性，避免在设置setnx成功之后在设置过期时间客户端崩溃导致死锁
4. 加锁的Value 值为一个唯一标示。可以采用UUID作为唯一标示。加锁成功后需要把唯一标示返回给客户端来用来客户端进行解锁操作

**解锁的正确姿势为：**

　　1. 需要拿加锁成功的唯一标示要进行解锁，从而保证加锁和解锁的是同一个客户端

　　2. 解锁操作需要比较唯一标示是否相等，相等再执行删除操作。这2个操作可以采用Lua脚本方式使2个命令的原子性。

### 如何保证缓存和数据库的双写一致性？

cache Aside pattern 缓存数据库读写模式

- 读的时候，先读缓存，缓存没有的话就读数据库，然后取出数据后放入缓存，同时返回响应。
- 写的时候，先更新数据库，然后再删除缓存（原因是更新缓存的代价有时候很高，同时这也涉及到lazy计算的思想）

### 手写一个LRU算法？

LRU是Least Recently Used的缩写，即最近最少使用。手写一个LRU算法，事实上对应LeetCode上146. LRU Cache原题

### Redis项目中如何使用的？

我是结合spring boot使用的。一般有两种方式，一种是直接通过RedisTemplate来使用，另一种是使用spring cache集成Redis（也就是注解的方式）。

### 关于跳表你知道多少？为什么不使用红黑树

跳表的核心思想是**“剪枝”**
如果是一个简单的链表，那么我们知道在链表中查找一个元素I的话，需要将整个链表遍历一次。

![img](https://picb.zhimg.com/80/v2-90d3217ca65ece919930fa6928e9c1de_720w.png)

如果是说链表是排序的，并且节点中还存储了“跳跃”的指向后续节点的指针的话，那么在查找一个节点时，仅仅需要遍历N/2个节点即可。

![img](https://picb.zhimg.com/80/v2-aea8a7ceef87542a7645b016544e29e5_720w.png)

从上图中已经可以看到"层"的出现使得时间复杂度降为原来的一半。

skiplist正是受这种多层链表的想法的启发而设计出来的。这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到**O(log n)**。

1 内存占用方面跳表比红黑树多，但是多的内存很有限
2 实现比红黑树简单
3 跟红黑树更方便的支持范围查询

Redis中跳跃表由zskiplistNode和zskiplist两个结构定义，前者结构包含：header、tail、level和length,后者结构包含：层、前进指针、后退指针、跨度、分值和成员对象。

